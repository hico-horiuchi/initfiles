#--------------------------------------------------------------------------------
# 環境変数
#--------------------------------------------------------------------------------
export LANG=ja_JP.UTF-8
export TERM='xterm-256color'
export EDITOR='emacsclient -nw'
export PATH=/Library/Internet\ Plug-Ins/JavaAppletPlugin.plugin/Contents/Home/bin:/usr/texbin:$HOME/Library/Python/2.7/bin:$HOME/.local/bin:$PATH
export LESS='-fRX'
export GREP_OPTIONS='--color=auto'
# 色を使用出来るようにする
autoload -Uz colors
colors
# ヒストリの設定
HISTFILE=~/.zsh_history
HISTSIZE=1000000
SAVEHIST=1000000
# 単語の区切り文字を指定する
autoload -Uz select-word-style
select-word-style default
# ここで指定した文字は単語区切りとみなされる
# / も区切りと扱うので、^W でディレクトリ1つ分を削除できる
zstyle ':zle:*' word-chars ' /=;@:{},|'
zstyle ':zle:*' word-style unspecified
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# OS
#--------------------------------------------------------------------------------
case ${OSTYPE} in
  darwin*)
    export GNU='g'
    export GOROOT=/usr/local/opt/go/libexec
    src_hilite_path='/usr/local/bin/src-hilite-lesspipe.sh'
    go_comp_path='/usr/local/share/zsh-completions/_golang'
    ansible_id_rsa=$HOME'/.ssh/ansible'
  ;;
  linux*)
    export GNU=''
    export GOROOT=/usr/local/go
    src_hilite_path='/usr/share/source-highlight/src-hilite-lesspipe.sh'
    go_comp_path='/usr/local/go/misc/zsh/go'
    ansible_id_rsa='/etc/ansible/id_rsa'
  ;;
esac
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# キーバインド
#--------------------------------------------------------------------------------
# Emacs 風キーバインドにする
bindkey -e
# Ctrl-R で履歴検索をするときに * でワイルドカードを使用出来るようにする
bindkey '^R' history-incremental-pattern-search-backward
# AquaSKK 用に Ctrl-J を無効化
bindkey -r '^J'
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# オプション
#--------------------------------------------------------------------------------
# 日本語ファイル名を表示可能にする
setopt print_eight_bit
# beep を無効にする
setopt no_beep
# フローコントロールを無効にする
setopt no_flow_control
# '#' 以降をコメントとして扱う
setopt interactive_comments
# ディレクトリ名だけでcdする
setopt auto_cd
# cd したら自動的にpushdする
setopt auto_pushd
# 重複したディレクトリを追加しない
setopt pushd_ignore_dups
# = の後はパス名として補完する
setopt magic_equal_subst
# 同時に起動したzshの間でヒストリを共有する
setopt share_history
# 同じコマンドをヒストリに残さない
setopt hist_ignore_all_dups
# ヒストリファイルに保存するとき、すでに重複したコマンドがあったら古い方を削除する
setopt hist_save_nodups
# スペースから始まるコマンド行はヒストリに残さない
setopt hist_ignore_space
# ヒストリに保存するときに余分なスペースを削除する
setopt hist_reduce_blanks
# 補完候補が複数あるときに自動的に一覧表示する
setopt auto_menu
# 高機能なワイルドカード展開を使用する
# setopt extended_glob
# 出力の文字列末尾に改行コードが無い場合でも表示
unsetopt promptcr
# プロンプト定義内で変数置換やコマンド置換を扱う
setopt prompt_subst
# 補完候補一覧でファイルの種別をマーク表示
setopt list_types
# 補完候補を一覧表示
setopt auto_list
# 補完候補を詰めて表示
setopt list_packed
# カッコの対応などを自動的に補完
setopt auto_param_keys
# ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
# setopt auto_param_slash
# 最後のスラッシュを自動的に削除しない
setopt noautoremoveslash
# バックグラウンドジョブの状態変化を即時報告
setopt notify
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# 補完
#--------------------------------------------------------------------------------
# 補完機能を有効にする
[ -d /usr/local/share/zsh-completions ] && fpath=(/usr/local/share/zsh-completions $fpath)
autoload -Uz compinit && compinit -u
# 補完候補のカーソル選択を有効に
zstyle ':completion:*' menu select
# 補完候補をグループ別に表示する
zstyle ':completion:*' format '%F{white}%B%d%b'
zstyle ':completion:*' group-name ''
# 補完で小文字でも大文字にマッチさせる
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
# 補完で展開時にプレフィクスを保持する
zstyle ':completion:*' keep-prefix
# ../ の後は今いるディレクトリを補完しない
zstyle ':completion:*' ignore-parents parent pwd ..
# sudo の後ろでコマンド名を補完する
zstyle ':completion:*:sudo:*' command-path \
    /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/X11R6/bin
# ps コマンドのプロセス名補完
zstyle ':completion:*:processes' command 'ps x -o pid,s,args'
# GNU ls の色定義を流用
eval `${GNU}dircolors ${HOME}/src/initfiles/terminal/dircolors.256dark`
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# エイリアス
#--------------------------------------------------------------------------------
# sudo の後のコマンドでエイリアスを有効にする
alias sudo='sudo '
# グローバルエイリアス
alias -g L='| less'
alias -g G='| grep'
alias -g N='> /dev/null 2> /dev/null &'
alias -g M='`git ls-files -m`'
# ユーザー定義
alias readlink="${GNU}readlink"
alias sed="${GNU}sed"
alias ls="${GNU}ls -1F --color=always --show-control-char"
alias ll="${GNU}ls -lF --color=always --show-control-char --time-style=+'%Y/%m/%d %H:%M'"
alias la="${GNU}ls -laF --color=always --show-control-char --time-style=+'%Y/%m/%d %H:%M'"
alias nkf_g='nkf --guess'
alias nkf_s='nkf -s --overwrite'
alias nkf_e='nkf -e --overwrite'
alias nkf_w='nkf -w --overwrite'
alias nkf_Lw='nkf -Lw --overwrite'
alias nkf_Lu='nkf -Lu --overwrite'
alias nkf_Lm='nkf -Lm --overwrite'
alias emacs='emacsclient -nw'
alias emacs_daemon='/Applications/Emacs.app/Contents/MacOS/Emacs --daemon'
alias kill_emacs="emacsclient -e '(progn (defun yes-or-no-p (p) t) (kill-emacs))'"
alias curl='curl -s'
alias gcc='gcc_o'
alias bundle_install='bundle install --jobs 4 --path vendor/bundler --binstubs vendor/bin --without doc production'
alias rails_s='bundle exec rails s --bind=0.0.0.0'
alias ssh_http='ssh -L 3000:sss.eng.kagawa-u.ac.jp:3000 sss'
alias ssh_rdp='ssh -L 3389:133.92.147.234:3389 sss'
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# 関数
#--------------------------------------------------------------------------------
function exists() { which $1 &> /dev/null }
function docker-ssh() { docker exec -i -t $1 /bin/bash }
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# プロンプト
#--------------------------------------------------------------------------------
# RPROMPT
RPROMPT=$'`branch-status-check`'
# 表示毎にPROMPTで設定されている文字列を評価する
setopt prompt_subst
# fg[color]表記と$reset_colorを使いたい
# @see https://wiki.archlinux.org/index.php/zsh
function branch-status-check() {
  local branchname suffix
  # .gitの中だから除外
  [[ '$PWD' =~ '/\.git(/.*)?$' ]] && return
  branchname=`get-branch-name`
  # ブランチ名が無いので除外
  [[ -z $branchname ]] && return
  suffix='%{'${reset_color}'%}'
  echo `get-branch-status`${suffix}
}
function get-branch-name() {
  local git==git
  # gitディレクトリじゃない場合のエラーは捨てます
  echo `${git} rev-parse --abbrev-ref HEAD 2> /dev/null`
}
function get-branch-status() {
  local git==git branchstatus branchname
  branchname=`get-branch-name`
  output=`${git} status 2> /dev/null`
  if [[ -n `echo $output | grep '^nothing to commit'` ]]; then
    branchstatus='%{'${fg[green]}'%}%{'${fg[black]}${bg[green]}'%}  '${branchname}
  elif [[ -n `echo $output | grep '^Untracked files:'` ]]; then
    branchstatus='%{'${fg[yellow]}'%}%{'${fg[black]}${bg[yellow]}'%}  '${branchname}
  elif [[ -n `echo $output | grep '^Changes not staged for commit:'` ]]; then
    branchstatus='%{'${fg[red]}'%}%{'${fg[black]}${bg[red]}'%}  '${branchname}
  else
    branchstatus='%{'${fg[cyan]}'%}%{'${fg[black]}${bg[cyan]}'%}  '${branchname}
  fi
  echo ${branchstatus}' '
}
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# wakatime
#--------------------------------------------------------------------------------
# hook function to send wakatime a tick
send_wakatime_heartbeat() {
  (wakatime --write --plugin "zsh-wakatime/0.0.1" --entity-type app --project Terminal --entity "$(waka_filename)"> /dev/null 2>&1 &)
}
# generate text to report as "filename" to the wakatime API
waka_filename() {
  if [ "x$WAKATIME_USE_DIRNAME" = "xtrue" ]; then
    # just use the current working directory
    echo "$PWD"
  else
    # only command without arguments to avoid senstive information
    echo "$history[$((HISTCMD-1))]" | cut -d ' ' -f 1
  fi
}
precmd_functions+=(send_wakatime_heartbeat)
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# powerline-shell
#--------------------------------------------------------------------------------
if exists powerline-shell; then
  function powerline_precmd() {
    PS1=$'\n'"$(powerline-shell --shell zsh $?) "
  }
  function install_powerline_precmd() {
    for s in "${precmd_functions[@]}"; do
      [ "$s" = 'powerline_precmd' ] && return
    done
    precmd_functions+=(powerline_precmd)
  }
  if [ "$TERM" != 'linux' ]; then
    install_powerline_precmd
  fi
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# fzf
#--------------------------------------------------------------------------------
if exists fzf; then
  source $(brew --prefix)/opt/fzf/shell/key-bindings.zsh
  export FZF_DEFAULT_OPTS='--reverse --inline-info --ansi'
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# k
#--------------------------------------------------------------------------------
k_path=$HOME'/src/k/k.sh'
if [ -f $k_path ]; then
  source $k_path
  alias ll='k -h --no-vcs'
  alias la='k -ah --no-vcs'
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# z
#--------------------------------------------------------------------------------
z_path=$HOME'/src/z/z.sh'
if [ -f $z_path ]; then
  source $z_path
  if exists fzf; then
    function fzf_z_search() {
      local res="$(_z -l 2>&1 | fzf --height 40% --nth 2.. --reverse --inline-info +s --tac --query "${*##-* }" | sed 's/^[0-9,.]* *//')"
      if [ -n $res ]; then
        BUFFER+="cd $res"
        zle accept-line
      else
        return 1
      fi
    }
  fi
  zle -N fzf_z_search
  bindkey '^F' fzf_z_search
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# auto-fu.zsh
#--------------------------------------------------------------------------------
auto_fu_path=$HOME'/src/auto-fu.zsh/auto-fu.zsh'
if [ -f $auto_fu_path ]; then
  source $auto_fu_path
  function zle-line-init() { auto-fu-init }
  zle -N zle-line-init
  # 「-azfu-」を表示させない
  zstyle ':auto-fu:var' postdisplay $''
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# source-highlight
#--------------------------------------------------------------------------------
if [ -f $src_hilite_path ]; then
  export LESSOPEN='| '$src_hilite_path' %s'
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# golang
#--------------------------------------------------------------------------------
if [ -f $go_comp_path ]; then
  export GOPATH=$HOME/.go
  export PATH=$GOPATH/bin:$GOROOT/bin:$PATH
  [ ! -d /usr/local/share/zsh-completions ] && source $go_comp_path
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# git
#--------------------------------------------------------------------------------
if exists fzf; then
  fbs() {
    local branches branch
    branches=$(git branch -a | grep -v '^*' | sed -e 's/^ *//g' -e 's/remotes\/origin\///g') &&
    branch=$(echo "$branches" | fzf --tac +s +m -e --ansi --reverse --height 40%) &&
    echo -n $(echo "$branch")
  }
  fts() {
    local tags tag
    tags=$(git tag) &&
    tag=$(echo "$tags" | fzf --tac +s +m -e --ansi --reverse --height 40%) &&
    echo -n $(echo "$tag")
  }
  fcs() {
    local commits commit
    commits=$(git log --color=always --reverse --date=short --pretty=format:"%C(yellow)<%h> %Cgreen[%ad] %Cred%an%Creset %s") &&
    commit=$(echo "$commits" | fzf --tac +s +m -e --ansi --reverse --height 40%) &&
    echo -n $(echo "$commit" | sed 's/^<\(.*\)> .*$/\1/')
  }
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# hub
#--------------------------------------------------------------------------------
hub_comp_path=$GOPATH'/src/github.com/github/hub/etc/hub.zsh_completion'
if [ -f $hub_comp_path ]; then
  function git() { hub "$@" }
  [ ! -d /usr/local/share/zsh-completions ] && source $hub_comp_path
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# tsuru
#--------------------------------------------------------------------------------
_tsuru_get_commands() {
    local -a commands
    local tasks
    tasks=$(tsuru 2> /dev/null | awk -F ' ' 'match($0, /^[ ]/) { if (!match($0, /(  help  |This command was removed)/)) { printf "%s:",$1; for(i=2; i<=NF; i++) { printf "%s ",$i }; printf "\n" } }')
    commands=("${(f)tasks}")
    _describe 'Tsuru commands' commands
}
_tsuru() {
    _arguments \
        "1: :_tsuru_get_commands"
}
compdef _tsuru tsuru
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# gom exec
#--------------------------------------------------------------------------------
if [ -f $go_comp_path ]; then
  function ge() { gom exec $* }
  function _ge() {
    if [ -d vendor/bin ]; then
      _arguments '*: :->'
      if [[ $CURRENT == 2 ]]; then
        _values 'gom exec' `\ls -1 vendor/bin`
      else
        _files
      fi
    fi
  }
  compdef _ge ge
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# rake
#--------------------------------------------------------------------------------
function _rake_refresh() {
  if [ ! -f .rake_tasks ]; then
    return 0;
  else
    return $([[ Rakefile -nt .rake_tasks ]])
  fi
}
function _rake() {
  if [ -f Rakefile ]; then
    if _rake_refresh; then
      bundle exec rake --silent --tasks | cut -d ' ' -f 2 > .rake_tasks
      ${GNU}sed -i -e 's/:/\\\:/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g' .rake_tasks
    fi
    _values 'rake' $(<.rake_tasks)
  fi
}
compdef _rake rake
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# bundle exec
#--------------------------------------------------------------------------------
function be() { bundle exec $* }
function _be() {
  if [ -d vendor/bin ]; then
    _arguments '*: :->'
    if [[ $CURRENT == 2 ]]; then
      _values 'bundle exec' `\ls -1 vendor/bin`
    elif [[ $CURRENT == 3 && $line[1] == 'rake' ]]; then
      _rake
    else
      _files
    fi
  fi
}
compdef _be be
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# ansible-ssh
#--------------------------------------------------------------------------------
function ansible-ssh() {
  ssh -i $ansible_id_rsa ansible@$1
}
if exists ! _ssh_hosts; then; _ssh; fi
compdef _ssh_hosts ansible-ssh
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# travis gem
#--------------------------------------------------------------------------------
[ -f $HOME/.travis/travis.sh ] && source $HOME/.travis/travis.sh
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# heroku toolbelt
#--------------------------------------------------------------------------------
[ -d /usr/local/heroku ] && export PATH=/usr/local/heroku/bin:$PATH
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# rbenv
#--------------------------------------------------------------------------------
[ -d $HOME/.rbenv ] && eval "$(rbenv init -)"
#--------------------------------------------------------------------------------
