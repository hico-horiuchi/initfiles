#--------------------------------------------------------------------------------
# 環境変数
#--------------------------------------------------------------------------------
export LANG=ja_JP.UTF-8
export TERM='xterm-256color'
export PATH=$HOME/.local/bin:$PATH
export GREP_OPTIONS='--color=auto'
# 色を使用出来るようにする
autoload -Uz colors
colors
# ヒストリの設定
HISTFILE=~/.zsh_history
HISTSIZE=1000000
SAVEHIST=1000000
function history-all { history -E 1 }
# 単語の区切り文字を指定する
autoload -Uz select-word-style
select-word-style default
# ここで指定した文字は単語区切りとみなされる
# / も区切りと扱うので、^W でディレクトリ1つ分を削除できる
zstyle ':zle:*' word-chars ' /=;@:{},|'
zstyle ':zle:*' word-style unspecified
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# direnv
#--------------------------------------------------------------------------------
# export EDITOR='emacs -nw'
# eval "$(direnv hook zsh)"
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# キーバインド
#--------------------------------------------------------------------------------
# emacs 風キーバインドにする
bindkey -e
# ^R で履歴検索をするときに * でワイルドカードを使用出来るようにする
bindkey '^R' history-incremental-pattern-search-backward
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# オプション
#--------------------------------------------------------------------------------
# 日本語ファイル名を表示可能にする
setopt print_eight_bit
# beep を無効にする
setopt no_beep
# フローコントロールを無効にする
setopt no_flow_control
# '#' 以降をコメントとして扱う
setopt interactive_comments
# ディレクトリ名だけでcdする
setopt auto_cd
# cd したら自動的にpushdする
setopt auto_pushd
# 重複したディレクトリを追加しない
setopt pushd_ignore_dups
# = の後はパス名として補完する
setopt magic_equal_subst
# 同時に起動したzshの間でヒストリを共有する
setopt share_history
# 同じコマンドをヒストリに残さない
setopt hist_ignore_all_dups
# ヒストリファイルに保存するとき、すでに重複したコマンドがあったら古い方を削除する
setopt hist_save_nodups
# スペースから始まるコマンド行はヒストリに残さない
setopt hist_ignore_space
# ヒストリに保存するときに余分なスペースを削除する
setopt hist_reduce_blanks
# 補完候補が複数あるときに自動的に一覧表示する
setopt auto_menu
# 高機能なワイルドカード展開を使用する
# setopt extended_glob
# 出力の文字列末尾に改行コードが無い場合でも表示
unsetopt promptcr
# プロンプト定義内で変数置換やコマンド置換を扱う
setopt prompt_subst
# 補完候補一覧でファイルの種別をマーク表示
setopt list_types
# 補完候補を一覧表示
setopt auto_list
# 補完候補を詰めて表示
setopt list_packed
# カッコの対応などを自動的に補完
setopt auto_param_keys
# ディレクトリ名の補完で末尾の / を自動的に付加し、次の補完に備える
# setopt auto_param_slash
# 最後のスラッシュを自動的に削除しない
setopt noautoremoveslash
# バックグラウンドジョブの状態変化を即時報告
setopt notify
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# 補完
#--------------------------------------------------------------------------------
# 補完機能を有効にする
autoload -Uz compinit
compinit
# 補完候補をグループ別に表示する
zstyle ':completion:*' menu select
zstyle ':completion:*' format '%B%d%b'
zstyle ':completion:*' group-name ''
# 補完で小文字でも大文字にマッチさせる
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
# 補完で展開時にプレフィクスを保持する
zstyle ':completion:*' keep-prefix
# ../ の後は今いるディレクトリを補完しない
zstyle ':completion:*' ignore-parents parent pwd ..
# sudo の後ろでコマンド名を補完する
zstyle ':completion:*:sudo:*' command-path \
    /usr/local/sbin /usr/local/bin /usr/sbin /usr/bin /sbin /bin /usr/X11R6/bin
# ps コマンドのプロセス名補完
zstyle ':completion:*:processes' command 'ps x -o pid,s,args'
# GNU ls の色定義を流用
eval `dircolors -b`
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
# 補完候補のカーソル選択を有効に
zstyle ':completion:*:default' menu select=1
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# エイリアス
#--------------------------------------------------------------------------------
# sudo の後のコマンドでエイリアスを有効にする
alias sudo='sudo '
# グローバルエイリアス
alias -g L='| more'
alias -g G='| grep'
alias -g N='> /dev/null 2> /dev/null &'
alias -g M='`git ls-files -m`'
# ユーザー定義
alias less='more'
alias ls='ls -1F --color=always --show-control-char'
alias ll='ls -lF --color=always --show-control-char --time-style=+"%Y/%m/%d %H:%M"'
alias la='ls -laF --color=always --show-control-char --time-style=+"%Y/%m/%d %H:%M"'
alias nkf_s='nkf -s --overwrite'
alias nkf_e='nkf -e --overwrite'
alias nkf_w='nkf -w --overwrite'
alias nkf_Lw='nkf -Lw --overwrite'
alias nkf_Lu='nkf -Lu --overwrite'
alias emacs='emacs -nw'
alias gcc='gcc_o'
alias bundle_install='bundle install --jobs=4 --path=vendor/bundler --binstubs=vendor/bin --without doc production'
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# プロンプト
#--------------------------------------------------------------------------------
# RPROMPT
RPROMPT=$'`branch-status-check`'
#表示毎にPROMPTで設定されている文字列を評価する
setopt prompt_subst
# fg[color]表記と$reset_colorを使いたい
# @see https://wiki.archlinux.org/index.php/zsh
function branch-status-check {
  local branchname suffix
  # .gitの中だから除外
  if [[ "$PWD" =~ '/\.git(/.*)?$' ]]; then
    return
  fi
  branchname=`get-branch-name`
  # ブランチ名が無いので除外
  if [[ -z $branchname ]]; then
    return
  fi
  suffix='%{'${reset_color}'%}'
  echo `get-branch-status`${suffix}
}
function get-branch-name {
  # gitディレクトリじゃない場合のエラーは捨てます
  echo `git rev-parse --abbrev-ref HEAD 2> /dev/null`
}
function get-branch-status {
  local branchstatus branchname
  branchname=`get-branch-name`
  output=`git status 2> /dev/null`
  if [[ -n `echo $output | grep "^nothing to commit"` ]]; then
    branchstatus='%{'${fg[green]}'%}⮂%{'${fg[black]}${bg[green]}'%} ⭠ '${branchname}
  elif [[ -n `echo $output | grep "^Untracked files:"` ]]; then
    branchstatus='%{'${fg[yellow]}'%}⮂%{'${fg[black]}${bg[yellow]}'%} ⭠ '${branchname}
  elif [[ -n `echo $output | grep "^Changes not staged for commit:"` ]]; then
    branchstatus='%{'${fg[red]}'%}⮂%{'${fg[black]}${bg[red]}'%} ⭠ '${branchname}
  else
    branchstatus='%{'${fg[cyan]}'%}⮂%{'${fg[black]}${bg[cyan]}'%} ⭠ '${branchname}
  fi
  echo ${branchstatus}' ' # `get-stash-status``get-merge-status``get-push-status`
}
# function get-stash-status {
#   local stashstatus
#   output=`git stash list 2> /dev/null | wc -l`
#   if [[ output -gt 0 ]]; then
#     stashstatus=' ⮃ S'${output}
#   fi
#   echo ${stashstatus}
# }
# function get-merge-status {
#   local mergestatus
#   output=`git rev-list origin/master..${get-branch-name} 2> /dev/null | wc -l`
#   if [[ output -gt 0 ]]; then
#     mergestatus=' ⮃ M'${output}
#   fi
#   echo ${mergestatus}
# }
# function get-push-status {
#   local pushstatus
#   output=`git rev-list origin/master..master 2> /dev/null | wc -l`
#   if [[ output -gt 0 ]]; then
#     pushstatus=' ⮃ P'${output}
#   fi
#   echo ${pushstatus}
# }
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# powerline-shell
#--------------------------------------------------------------------------------
powerline_shell_path=$HOME'/src/powerline-shell/powerline-shell.py'
if [  -f $powerline_shell_path ] ; then
  function powerline_precmd() {
    export PS1=$'\n'"$($powerline_shell_path $? --shell zsh) "
  }
  function install_powerline_precmd() {
    for s in '${precmd_functions[ @]}'; do
      if [  '$s' = 'powerline_precmd' ]; then return; fi
    done
    precmd_functions+=(powerline_precmd)
  }
  install_powerline_precmd
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# percol
#--------------------------------------------------------------------------------
function exists { which $1 &> /dev/null }
if exists percol; then
  function percol_select_history() {
    local tac
    exists gtac && tac="gtac" || { exists tac && tac="tac" || { tac="tail -r" } }
    BUFFER=$(fc -l -n 1 | eval $tac | percol --query "$LBUFFER" --prompt "<bold><magenta>HISTORY ></magenta></bold> %q")
    CURSOR=$#BUFFER
    zle -R -c
  }
  zle -N percol_select_history
  bindkey '^R' percol_select_history
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# source-highlight
#--------------------------------------------------------------------------------
src_hilite_path='/usr/share/source-highlight/src-hilite-lesspipe.sh'
if [ -f $src_hilite_path ] ; then
  export LESS='-R'
  export LESSOPEN='| '$src_hilite_path' %s'
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# auto-fu.zsh
#--------------------------------------------------------------------------------
auto_fu_path=$HOME'/src/auto-fu.zsh/auto-fu.zsh'
if [ -f $auto_fu_path ] ; then
  source $auto_fu_path
  function zle-line-init () { auto-fu-init }
  zle -N zle-line-init
  # 「-azfu-」を表示させない
  zstyle ':auto-fu:var' postdisplay $''
fi
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# rake
#--------------------------------------------------------------------------------
_rake_refresh () {
  if [[ ! -f .rake_tasks ]]; then
    return 0;
  else
    return $([[ Rakefile -nt .rake_tasks ]])
  fi
}
_rake () {
  if [[ -f Rakefile ]]; then
    if _rake_refresh; then
      bundle exec rake --silent --tasks | cut -d " " -f 2 > .rake_tasks
      sed -i -e 's/:/\\\:/g' -e 's/\[/\\[/g' -e 's/\]/\\]/g' .rake_tasks
    fi
    _values "rake" $(<.rake_tasks)
  fi
}
# compdef _rake rake
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# bundle exec
#--------------------------------------------------------------------------------
be () { bundle exec $* }
_be () {
  if [[ -d vendor/bin ]]; then
    _arguments '*: :->'
    if [[ $CURRENT == 2 ]]; then
      _values "bundle exec" `\ls -1 vendor/bin`
    elif [[ $CURRENT == 3 && $line[1] == "rake" ]]; then
      _rake
    else
      _files
    fi
  fi
}
compdef _be be
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# ansible-ssh
#--------------------------------------------------------------------------------
function ansible-ssh() {
  ssh -i /etc/ansible/id_rsa ansible@$1
}
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# travis gem
#--------------------------------------------------------------------------------
[ -f /home/hiconyan/.travis/travis.sh ] && source /home/hiconyan/.travis/travis.sh
#--------------------------------------------------------------------------------

#--------------------------------------------------------------------------------
# heroku toolbelt
#--------------------------------------------------------------------------------
export PATH="/usr/local/heroku/bin:$PATH"
#--------------------------------------------------------------------------------
